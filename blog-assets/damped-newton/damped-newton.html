<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>Damped Newton’s Method with Self-Concordant Function</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='damped-newton.css' rel='stylesheet' type='text/css' /> 
<meta content='damped-newton.tex' name='src' /> 
</head><body>
   <div class='maketitle'>
                                                                                         
                                                                                         
                                                                                         
                                                                                         

<h2 class='titleHead'>Damped Newton’s Method with Self-Concordant Function</h2>
 <div class='author'><span class='ecrm-1200'>Ziwen Wang</span></div><br />
<div class='date'><span class='ecrm-1200'>February 16, 2026</span></div>
   </div>
   <h3 class='sectionHead' id='theoretical-discussion'><span class='titlemark'>1   </span> <a id='x1-10001'></a>Theoretical discussion</h3>
<!-- l. 58 --><p class='noindent'>In this writing we will review how damped newton method works and provide
an implementation of it. Throughout, we will assume that the given function
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math> is
strictly convex and twice differentiable. Newton’s method can be thought of finding the minimizer of
Taylor’s second order approximation,
</p><!-- l. 63 --><p class='indent'>
<!-- tex4ht:inline --></p><!-- l. 63 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 64 --><p class='nopar'> The exact minimizer assuming strict convexity is unique and has the following form,
<!-- tex4ht:inline --></p><!-- l. 66 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow>
   <mstyle class='text'><mtext>arg</mtext></mstyle></mrow><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup></mrow></msub><mo class='MathClass-open' stretchy='false'>{</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
                                                                                         
                                                                                         
<!-- l. 68 --><p class='nopar'>
</p><!-- l. 70 --><p class='indent'>   Let us define the decrement direction at iteration
<!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> as
<!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>d</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, then
the update step can be rewritten as,
<!-- tex4ht:inline --></p><!-- l. 73 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                 <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>d</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mspace class='quad' width='1em'></mspace><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 73 --><p class='nopar'> With step size <!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>, this
update rule is referred as the pure newton step, while this seems fine but it only converges (in fact quadratically) if the
initial starting point <!-- l. 76 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
is close enough to minimizer and with the assumption that the function
<!-- l. 77 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> is
strongly convex and Lipschtiz continuous.
</p>
   <div class='newtheorem'>
<!-- l. 80 --><p class='noindent'><span class='head'>
<a id='x1-1001r1'></a>
<span class='ecbx-1095'>Lemma 1 </span>(Newton’s method is affine invariant)<span class='ecbx-1095'>.</span>  </span><span class='ecti-1095'>Given an invertible matrix </span><!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi><mo class='MathClass-bin' stretchy='false'>×</mo><mi>m</mi></mrow></msup></mrow></math>
<span class='ecti-1095'>and a convex function </span><!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math><span class='ecti-1095'>.
Let </span><!-- l. 83 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></mrow></math>
<span class='ecti-1095'>be newton iterates of </span><!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>f</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Ax</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
<span class='ecti-1095'>with starting point </span><!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math>
<span class='ecti-1095'>respectively. Then </span><!-- l. 85 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></mrow></math><span class='ecti-1095'>.</span>
</p>
   </div>
<!-- l. 86 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 89 --><p class='indent'>   <span class='head'>
<span class='ecti-1095'>Proof.</span> </span>Notice that <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow></msub><mover accent='true'><mrow><mi>f</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mi>T</mi> </mrow></msup><msub><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mi>x</mi></mrow></msub><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Ax</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and <!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mn>2</mn></mrow></msubsup><mover accent='true'><mrow><mi>f</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Ax</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mi>T</mi> </mrow></msup><msubsup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msubsup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Ax</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>A</mi></mrow></math>
and by induction we have
                                                                                         
                                                                                         
</p><!-- tex4ht:inline --><!-- l. 102 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                           <mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub></mtd>                           <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                               <mtd class='align-label' columnalign='right'></mtd>                           <mtd class='align-label'>
                           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>T</mi> </mrow></msup><msup><mrow><mi>A</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                           <mtd class='align-label' columnalign='right'></mtd>                           <mtd class='align-label'>
                           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                                  <mtd class='align-label' columnalign='right'></mtd>                           <mtd class='align-label'>
                           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                               <mtd class='align-label' columnalign='right'></mtd>                           <mtd class='align-label'>
                           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow>
<mi>i</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                                                 <mtd class='align-label' columnalign='right'></mtd>                           <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
                                                                                        □
   </div>
<!-- l. 105 --><p class='indent'>   Note at optimality we have <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
so one way to measure convergence is by bounding upper bounding
<!-- l. 106 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>∥</mo></mrow></math>, but notice that
<!-- l. 106 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>∥</mo></mrow></math> is not affine
invariant i.e. <!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≠</mo><mo class='MathClass-open' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Ax</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>∥</mo></mrow></math>
so instead we have the following measure,
<!-- tex4ht:inline --></p><!-- l. 109 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>T</mi> </mrow> </msup> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn> </mrow> </msup> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn> </mrow> </msup> <mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>∥</mo><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow><mo class='MathClass-close' stretchy='false'>∥</mo></mrow><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></msub>
</mrow></math>
<!-- l. 110 --><p class='nopar'> which becomes affine invariant and can be interpreted as an induced norm by the PD matrix
<!-- l. 112 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></math>. So now instead of
bounding on <!-- l. 112 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>∥</mo></mrow></math> we
can try to bound <!-- l. 113 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p><!-- l. 115 --><p class='indent'>   Under the assumption that <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
is self concordant with constant 1 one can show that
<!-- l. 116 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo><msup><mrow> <mfrac><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow> 
<mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></mfrac></mrow><mrow><mn>2</mn></mrow></msup></mrow></math> (in order for it to
decrease we need <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn></mrow></math>
), but this still assumes a good starting point (which is the condition
<!-- l. 119 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn></mrow></math>). It
turns out if we change the step size then we are able to achieve global convergence but before we do so, we
shall define self-concordant functions more formally.
                                                                                         
                                                                                         
</p>
   <div class='newtheorem'>
<!-- l. 125 --><p class='noindent'><span class='head'>
<a id='x1-1002r2'></a>
<span class='ecbx-1095'>Definition 2 </span>(Self-concordant function)<span class='ecbx-1095'>.</span>  </span>A                                                             function
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
is          called          self-concordant          if          there          exists          a          constant
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>
such that
<!-- tex4ht:inline --></p><!-- l. 127 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                             <mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>D</mi></mrow><mrow><mn>3</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>u</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>u</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>2</mn><msub><mrow><mi>M</mi></mrow><mrow>
<mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>∥</mo><mi>u</mi><msubsup><mrow><mo class='MathClass-close' stretchy='false'>∥</mo></mrow><mrow><msup><mrow><mi class='MathClass-op'>∇</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>3</mn></mrow></msubsup>
</mrow></math>
<!-- l. 128 --><p class='nopar'> holds for all <!-- l. 129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi mathvariant='italic'>domf</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>
and <!-- l. 129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>u</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>.
</p>
   </div>
<!-- l. 131 --><p class='indent'>
</p><!-- l. 133 --><p class='indent'>   We now give three different stepping sizes and discuss their convergence properties, their advantage
and disadvantages.
</p><!-- l. 136 --><p class='indent'>
     </p><dl class='enumerate-enumitem'><dt class='enumerate-enumitem'>
   1. </dt><dd class='enumerate-enumitem'>(Standard Newton’s method) <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
     </dd><dt class='enumerate-enumitem'>
   2. </dt><dd class='enumerate-enumitem'>(Damped Newton’s method) <!-- l. 137 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>     <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></mfrac></mrow></math>,
     </dd><dt class='enumerate-enumitem'>
   3. </dt><dd class='enumerate-enumitem'>(Intermediate Newton’s method) <!-- l. 138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>       <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><mfrac><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></mfrac></mrow></mfrac></mrow></math>,
     where <!-- l. 140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.</dd></dl>
<!-- l. 142 --><p class='noindent'>From above it is not hard to see that the following inequality of the steps sizes holds,
                                                                                         
                                                                                         
<!-- tex4ht:inline --></p><!-- l. 144 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                     <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math>
<!-- l. 144 --><p class='nopar'> Method <!-- l. 145 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> uses the most
aggressive and <!-- l. 145 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> uses the least
aggressive stepping size, <!-- l. 146 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is somewhere in the middle hence the name intermediate. So from here can almost expect that if
<!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> doesn’t converge
then so does <!-- l. 148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
<!-- l. 148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. NOTE: Method
<!-- l. 148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> always generates a monotonically
decreasing sequence i.e. <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, and
indeed this also holds for method <!-- l. 150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
as given in the following theorem.
</p>
   <div class='newtheorem'>
<!-- l. 152 --><p class='noindent'><span class='head'>
<a id='x1-1006r3'></a>
<span class='ecbx-1095'>Theorem 3 </span>(Global Convergence)<span class='ecbx-1095'>.</span>  </span><span class='cite'><span class='ecti-1095'>[</span><a href='#Xnesterov2018lectures'><span class='ecti-1095'>1</span></a><span class='ecti-1095'>]</span></span> <span class='ecti-1095'>The following holds for any</span>
<!-- l. 152 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math> <span class='ecti-1095'>and let</span>
<!-- l. 153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></math> <span class='ecti-1095'>denote
the newton iterates,</span>
     </p><dl class='enumerate-enumitem'><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>1.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Standard Newton’s method) No guarantee on monotonically decreasing.</span>
     </dd><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>2.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Damped Newton’s method)</span>
     <!-- tex4ht:inline --><!-- l. 156 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                     <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msubsup><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow><mrow><mn>2</mn></mrow></msubsup></mrow></mfrac><mi>ω</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math>
                                                                                         
                                                                                         
     <!-- l. 157 --><p class='nopar'> <span class='ecti-1095'>where </span><!-- l. 158 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ω</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>ln</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math><span class='ecti-1095'>.</span>
     </p></dd><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>3.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Intermediate Newton’s method)</span>
     <!-- tex4ht:inline --><!-- l. 160 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
           <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mo class='MathClass-open' stretchy='false'>[</mo>         <mfrac><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><mn>2</mn><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mn>2</mn></mrow></munderover><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo>                   <mfrac><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
<mrow><mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo>
</mrow></math>
     <!-- l. 162 --><p class='nopar'></p></dd></dl>
   </div>
<!-- l. 164 --><p class='indent'>
</p><!-- l. 166 --><p class='indent'>   From the above global convergence theorem we can see that if
<!-- l. 167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is
relatively large then Damped Newton’s method would be better. We have the following theorem for their
convergence behavior.
</p>
   <div class='newtheorem'>
<!-- l. 171 --><p class='noindent'><span class='head'>
<a id='x1-1010r4'></a>
<span class='ecbx-1095'>Theorem 4 </span>(Convergence Rate)<span class='ecbx-1095'>.</span>  </span><span class='cite'><span class='ecti-1095'>[</span><a href='#Xnesterov2018lectures'><span class='ecti-1095'>1</span></a><span class='ecti-1095'>]</span></span> <span class='ecti-1095'>Let </span><!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi mathvariant='italic'>dom</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>f</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
<span class='ecti-1095'>and </span><!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math><span class='ecti-1095'>, let</span>
<!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup></math> <span class='ecti-1095'>be the point generated by one
step of newton’s method (either </span><!-- l. 173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>or </mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math><span class='ecti-1095'>).
Then </span><!-- l. 174 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi mathvariant='italic'>domf</mi></mrow></math>
<span class='ecti-1095'>and the following holds,</span>
     </p><dl class='enumerate-enumitem'><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>1.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Standard Newton’s method) If </span><!-- l. 176 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn></mrow></math>
     <span class='ecti-1095'>then</span>
                                                                                         
                                                                                         
     <!-- tex4ht:inline --><!-- l. 177 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                               <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo>   <mfrac><mrow><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi></mrow>
<mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
     <!-- l. 178 --><p class='nopar'>
     </p></dd><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>2.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Damped Newton’s method)</span>
     <!-- tex4ht:inline --><!-- l. 179 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                         <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msub><mrow><mi>M</mi></mrow><mrow>
<mi>f</mi></mrow></msub><msup><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo>      <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
     <!-- l. 180 --><p class='nopar'>
     </p></dd><dt class='enumerate-enumitem'>
  <span class='ecti-1095'>3.</span> </dt><dd class='enumerate-enumitem'><span class='ecti-1095'>(Intermediate Newton’s method) If </span><!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mn>3</mn></mrow></msubsup><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>i</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>1</mn></mrow></math>
     <span class='ecti-1095'>then</span>
     <!-- tex4ht:inline --><!-- l. 182 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <msub><mrow><mi>λ</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msub><mrow><mi>M</mi></mrow><mrow>
<mi>f</mi></mrow></msub><msup><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>M</mi></mrow><mrow>
<mi>f</mi></mrow></msub><mi>λ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo>        <mfrac><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi></mrow> 
<mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msup><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>M</mi></mrow><mrow>
<mi>f</mi></mrow></msub><mi>λ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
     <!-- l. 184 --><p class='nopar'></p></dd></dl>
                                                                                         
                                                                                         
   </div>
<!-- l. 186 --><p class='indent'>    Notice that even though the stepping size of
<!-- l. 187 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is
more aggressive the convergence analysis doesn’t actually yield a better bound compared to
<!-- l. 188 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> or
<!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> (why? consider
when <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>1</mn></mrow></math>
then it yields a very bad bound), this suggests that we should completely abandon
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Now method
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is almost a linear
convergence since when <!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub></mrow></math>
is very big then the term <!-- l. 192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><msup><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi></mrow></mfrac></mrow></math>
dominates Method <!-- l. 194 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
does not require any condition on how close our current iterate is to the optimal solution so the idea is then always run
method <!-- l. 195 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> then switch
to method <!-- l. 196 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> when we
satisfy the condition <!-- l. 196 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mn>3</mn></mrow></msubsup><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>f</mi></mrow></msub><mi>λ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>i</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>1</mn></mrow></math>
which is yields a quadratic convergence at the end.
</p><!-- l. 200 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='implementation'><span class='titlemark'>2   </span> <a id='x1-20002'></a>Implementation</h3>
<!-- l. 201 --><p class='noindent'>We wish to adapt Newton’s method to any function we wish including log barrier functions and
potentially many other barrier functions. Essentially Newton’s algorithm can be abstracted as
follows,
<a id='x1-2001r1'></a>
</p><!-- l. 205 --><p class='noindent'></p><div class='minipage' id='newtons-method'>   <a id='x1-2003'></a>
   <span class='ecbx-1095'>Input:</span> Initial
          guess
          <!-- l. 207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msub></math>,
          function
          <!-- l. 207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>,
          derivative
          <!-- l. 207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
   <!-- l. 208 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>←</mo> <mn>0</mn></mrow></math>;
   <span class='ecbx-1095'>while</span> <span class='ecti-1095'>Not
    converged</span> <span class='ecbx-1095'>do</span>
    
   <!-- l. 213 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>←</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>d</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>;
   <!-- l. 213 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>←</mo> <mi>k</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>;
   <span class='ecbx-1095'>end
                            Algorithm 1:</span> Newton’s Method                               </div>
                                                                                         
                                                                                         
<!-- l. 215 --><p class='indent'>   Both <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>d</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>
may depend on the gradient and hessian. The condition to check convergence may depend on the function
value, gradient, current solution, and current iterates. There are lots of ways to do this but one easy
way is to: Implement a main newton routine and let the user provide lambda functions to
compute the required information. But there are several caveats to this approach that I can think
of,
</p><!-- l. 223 --><p class='indent'>
     </p><dl class='enumerate-enumitem'><dt class='enumerate-enumitem'>
   1. </dt><dd class='enumerate-enumitem'>First this method does not allow compiler optimiztion in particular function inlining. To my
     knowledge, nor runtime polymorphism can achieve this (though I think with more aggressive
     compiler  optimization  you  can  still  achieve  this).  So  instead  we  will  need  compile  time
     polymorphism (speficially CRTP Curiously Recurring Template Pattern) that uses template.
     Just an aside: One may ask why would function inlining be important here? Since the only
     difference between enabling compile time polymorphism and runtime polymorphism here is
     to inline the actual call to gradient/hessian and no matter what we do the calls inside of
     gradient/hessian would already be optimized so the only difference is that we do not need to
     pay the overhead of virtual table in runtime polymorphism? Not really, usually computing
     the gradient and hessian could involve the same intermediate computation, if we then inlined
     both gradient/hessian then compiler’s can avoid the same computation.
     </dd><dt class='enumerate-enumitem'>
   2. </dt><dd class='enumerate-enumitem'>If we used compile time polymorphism then usually this creates a bunch of weird error messages
     that are harder to resolve. To address this problem and to increase the readability of our code
     we use Concept which acts as a compile time contract.
     </dd><dt class='enumerate-enumitem'>
   3. </dt><dd class='enumerate-enumitem'>Recently I got pretty interested into template programming and how it can be used for compile
     time optimization and so I decided to implement some toy example.</dd></dl>
   <!-- l. 246 -->
<pre class='lstlisting' id='listing-1'><span class='label'><a id='x1-2007r1'></a><span class='ecrm-0600'>1</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>ifndef</span></span><span style='color:#000000'> <span class='ectt-1000'>NEWTON</span> 
</span><span class='label'><a id='x1-2008r2'></a><span class='ecrm-0600'>2</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>define</span></span><span style='color:#000000'> <span class='ectt-1000'>NEWTON</span> 
</span><span class='label'><a id='x1-2009r3'></a><span class='ecrm-0600'>3</span></span> 
<span class='label'><a id='x1-2010r4'></a><span class='ecrm-0600'>4</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>include</span></span><span style='color:#000000'> <span class='ectt-1000'>&lt;Eigen/Dense&gt;</span> 
</span><span class='label'><a id='x1-2011r5'></a><span class='ecrm-0600'>5</span></span> 
<span class='label'><a id='x1-2012r6'></a><span class='ecrm-0600'>6</span></span><span style='color:#0000FF'><span class='ectt-1000'>using</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>namespace</span></span><span style='color:#000000'> <span class='ectt-1000'>Eigen;</span> 
</span><span class='label'><a id='x1-2013r7'></a><span class='ecrm-0600'>7</span></span> 
<span class='label'><a id='x1-2014r8'></a><span class='ecrm-0600'>8</span></span><span style='color:#0000FF'><span class='ectt-1000'>template</span></span><span style='color:#000000'> <span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>typename</span></span><span style='color:#000000'> <span class='ectt-1000'>T&gt;</span> 
</span><span class='label'><a id='x1-2015r9'></a><span class='ecrm-0600'>9</span></span><span style='color:#000000'><span class='ectt-1000'>concept</span></span><span style='color:#000000'> <span class='ectt-1000'>ObjectiveImpl = requires(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>T &amp;obj,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd &amp;x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it) {</span> 
</span><span class='label'><a id='x1-2016r10'></a><span class='ecrm-0600'>10</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.value_impl(x) } -&gt; std::convertible_to&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'><span class='ectt-1000'>&gt;;</span></span> 
<span class='label'><a id='x1-2017r11'></a><span class='ecrm-0600'>11</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.gradient_impl(x) } -&gt; std::convertible_to&lt;VectorXd&gt;;</span> 
</span><span class='label'><a id='x1-2018r12'></a><span class='ecrm-0600'>12</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.hessian_impl(x) } -&gt; std::convertible_to&lt;MatrixXd&gt;;</span> 
</span><span class='label'><a id='x1-2019r13'></a><span class='ecrm-0600'>13</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.newtonDirection_impl(x) } -&gt; std::same_as&lt;VectorXd&gt;;</span> 
</span><span class='label'><a id='x1-2020r14'></a><span class='ecrm-0600'>14</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.converged_impl(x, it) } -&gt; std::same_as&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>bool</span></span><span style='color:#000000'><span class='ectt-1000'>&gt;;</span></span> 
<span class='label'><a id='x1-2021r15'></a><span class='ecrm-0600'>15</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>{</span></span><span style='color:#000000'> <span class='ectt-1000'>obj.stepsize_impl(x, it) } -&gt; std::same_as&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'><span class='ectt-1000'>&gt;;</span></span> 
<span class='label'><a id='x1-2022r16'></a><span class='ecrm-0600'>16</span></span><span style='color:#000000'><span class='ectt-1000'>};</span></span> 
<span class='label'><a id='x1-2023r17'></a><span class='ecrm-0600'>17</span></span> 
<span class='label'><a id='x1-2024r18'></a><span class='ecrm-0600'>18</span></span><span style='color:#0000FF'><span class='ectt-1000'>template</span></span><span style='color:#000000'> <span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>class</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived&gt;</span> </span><span style='color:#0000FF'><span class='ectt-1000'>class</span></span><span style='color:#000000'> <span class='ectt-1000'>ObjectiveBase {</span> 
</span><span class='label'><a id='x1-2025r19'></a><span class='ecrm-0600'>19</span></span><span style='color:#0000FF'><span class='ectt-1000'>public</span></span><span style='color:#000000'><span class='ectt-1000'>:</span></span> 
<span class='label'><a id='x1-2026r20'></a><span class='ecrm-0600'>20</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>value(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2027r21'></a><span class='ecrm-0600'>21</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>value_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2028r22'></a><span class='ecrm-0600'>22</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2029r23'></a><span class='ecrm-0600'>23</span></span> 
<span class='label'><a id='x1-2030r24'></a><span class='ecrm-0600'>24</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>gradient(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2031r25'></a><span class='ecrm-0600'>25</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>gradient_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2032r26'></a><span class='ecrm-0600'>26</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2033r27'></a><span class='ecrm-0600'>27</span></span> 
<span class='label'><a id='x1-2034r28'></a><span class='ecrm-0600'>28</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>MatrixXd</span></span><span style='color:#000000'> <span class='ectt-1000'>hessian(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2035r29'></a><span class='ecrm-0600'>29</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>hessian_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2036r30'></a><span class='ecrm-0600'>30</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2037r31'></a><span class='ecrm-0600'>31</span></span> 
<span class='label'><a id='x1-2038r32'></a><span class='ecrm-0600'>32</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>MatrixXd</span></span><span style='color:#000000'> <span class='ectt-1000'>newtonDirection(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2039r33'></a><span class='ecrm-0600'>33</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>newtonDirection_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2040r34'></a><span class='ecrm-0600'>34</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2041r35'></a><span class='ecrm-0600'>35</span></span> 
<span class='label'><a id='x1-2042r36'></a><span class='ecrm-0600'>36</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>bool</span></span><span style='color:#000000'> <span class='ectt-1000'>converged(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2043r37'></a><span class='ecrm-0600'>37</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>converged_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>it);</span> 
</span><span class='label'><a id='x1-2044r38'></a><span class='ecrm-0600'>38</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2045r39'></a><span class='ecrm-0600'>39</span></span> 
<span class='label'><a id='x1-2046r40'></a><span class='ecrm-0600'>40</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>stepsize(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2047r41'></a><span class='ecrm-0600'>41</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>static_cast</span></span><span style='color:#000000'><span class='ectt-1000'>&lt;</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>Derived*&gt;(</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>)</span></span><span style='color:#000000'><span class='ectt-1000'>-&gt;</span></span><span style='color:#000000'><span class='ectt-1000'>stepsize_impl</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>x</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>it);</span> 
</span><span class='label'><a id='x1-2048r42'></a><span class='ecrm-0600'>42</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2049r43'></a><span class='ecrm-0600'>43</span></span><span style='color:#000000'><span class='ectt-1000'>};</span></span> 
<span class='label'><a id='x1-2050r44'></a><span class='ecrm-0600'>44</span></span> 
<span class='label'><a id='x1-2051r45'></a><span class='ecrm-0600'>45</span></span><span style='color:#0000FF'><span class='ectt-1000'>template</span></span><span style='color:#000000'> <span class='ectt-1000'>&lt;ObjectiveImpl Obj&gt;</span> 
</span><span class='label'><a id='x1-2052r46'></a><span class='ecrm-0600'>46</span></span><span style='color:#0000FF'><span class='ectt-1000'>class</span></span><span style='color:#000000'> <span class='ectt-1000'>NewtonSolver {</span> 
</span><span class='label'><a id='x1-2053r47'></a><span class='ecrm-0600'>47</span></span><span style='color:#0000FF'><span class='ectt-1000'>public</span></span><span style='color:#000000'><span class='ectt-1000'>:</span></span> 
<span class='label'><a id='x1-2054r48'></a><span class='ecrm-0600'>48</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>NewtonSolver</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>Obj</span></span><span style='color:#000000'><span class='ectt-1000'>&amp;</span></span><span style='color:#000000'> <span class='ectt-1000'>objective) : obj_(objective) {}</span> 
</span><span class='label'><a id='x1-2055r49'></a><span class='ecrm-0600'>49</span></span> 
<span class='label'><a id='x1-2056r50'></a><span class='ecrm-0600'>50</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>bool</span></span><span style='color:#000000'> <span class='ectt-1000'>solve() {</span> 
</span><span class='label'><a id='x1-2057r51'></a><span class='ecrm-0600'>51</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>i = 0;</span> 
</span><span class='label'><a id='x1-2058r52'></a><span class='ecrm-0600'>52</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>while</span></span><span style='color:#000000'><span class='ectt-1000'>(!</span></span><span style='color:#000000'><span class='ectt-1000'>obj_</span></span><span style='color:#000000'><span class='ectt-1000'>.</span></span><span style='color:#000000'><span class='ectt-1000'>converged</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#000000'><span class='ectt-1000'>cur_sol_</span></span><span style='color:#000000'><span class='ectt-1000'>,</span></span><span style='color:#000000'> <span class='ectt-1000'>i)) {</span> 
</span><span class='label'><a id='x1-2059r53'></a><span class='ecrm-0600'>53</span></span><span class='ectt-1000'>            </span><span style='color:#000000'><span class='ectt-1000'>cur_sol_</span></span><span style='color:#000000'> <span class='ectt-1000'>= cur_sol_ + obj_.stepsize(cur_sol_, i) * obj_.newtonDirection(cur_sol_);</span> 
</span><span class='label'><a id='x1-2060r54'></a><span class='ecrm-0600'>54</span></span><span class='ectt-1000'>            </span><span style='color:#000000'><span class='ectt-1000'>++</span></span><span style='color:#000000'><span class='ectt-1000'>i</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2061r55'></a><span class='ecrm-0600'>55</span></span><span class='ectt-1000'>        </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2062r56'></a><span class='ecrm-0600'>56</span></span><span class='ectt-1000'>        </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>true</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2063r57'></a><span class='ecrm-0600'>57</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2064r58'></a><span class='ecrm-0600'>58</span></span> 
<span class='label'><a id='x1-2065r59'></a><span class='ecrm-0600'>59</span></span><span class='ectt-1000'>    </span><span style='color:#009900'><span class='ectt-1000'>//</span></span><span style='color:#009900'> <span class='ectt-1000'>TODO: Currently max_iter_ and tol_ are not used...</span> 
</span><span class='label'><a id='x1-2066r60'></a><span class='ecrm-0600'>60</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>NewtonSolver</span></span><span style='color:#000000'><span class='ectt-1000'>&amp;</span></span><span style='color:#000000'> <span class='ectt-1000'>set_max_iter(</span></span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>n) { max_iter_ = n;</span> </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>*</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span><span style='color:#000000'> <span class='ectt-1000'>}</span> 
</span><span class='label'><a id='x1-2067r61'></a><span class='ecrm-0600'>61</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>NewtonSolver</span></span><span style='color:#000000'><span class='ectt-1000'>&amp;</span></span><span style='color:#000000'> <span class='ectt-1000'>set_tolerance_max_iter(</span></span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>tol) { tol_ = tol;</span> </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>*</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span><span style='color:#000000'> <span class='ectt-1000'>}</span> 
</span><span class='label'><a id='x1-2068r62'></a><span class='ecrm-0600'>62</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>NewtonSolver</span></span><span style='color:#000000'><span class='ectt-1000'>&amp;</span></span><span style='color:#000000'> <span class='ectt-1000'>set_initial_sol(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x) { cur_sol_ = x;</span> </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>*</span></span><span style='color:#0000FF'><span class='ectt-1000'>this</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span><span style='color:#000000'> <span class='ectt-1000'>}</span> 
</span><span class='label'><a id='x1-2069r63'></a><span class='ecrm-0600'>63</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>get_sol() {</span> </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>cur_sol_; }</span> 
</span><span class='label'><a id='x1-2070r64'></a><span class='ecrm-0600'>64</span></span><span style='color:#0000FF'><span class='ectt-1000'>private</span></span><span style='color:#000000'><span class='ectt-1000'>:</span></span> 
<span class='label'><a id='x1-2071r65'></a><span class='ecrm-0600'>65</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>Obj</span></span><span style='color:#000000'><span class='ectt-1000'>&amp;</span></span><span style='color:#000000'> <span class='ectt-1000'>obj_;</span> 
</span><span class='label'><a id='x1-2072r66'></a><span class='ecrm-0600'>66</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>max_iter_ = 100;</span> 
</span><span class='label'><a id='x1-2073r67'></a><span class='ecrm-0600'>67</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>tol_ = 1e-8;</span> 
</span><span class='label'><a id='x1-2074r68'></a><span class='ecrm-0600'>68</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>cur_sol_;</span> 
</span><span class='label'><a id='x1-2075r69'></a><span class='ecrm-0600'>69</span></span><span style='color:#000000'><span class='ectt-1000'>};</span></span> 
<span class='label'><a id='x1-2076r70'></a><span class='ecrm-0600'>70</span></span> 
<span class='label'><a id='x1-2077r71'></a><span class='ecrm-0600'>71</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>endif</span></span><span style='color:#000000'> </span><span style='color:#009900'><span class='ectt-1000'>//</span></span><span style='color:#009900'> <span class='ectt-1000'>NEWTON</span></span></pre>
<!-- l. 321 --><p class='indent'>   As on how to use this library, we need to provide an derived class that inherits from ObjectiveBase
that provides all the information NewtonSolver needs. We provide an example of the log barrier
function,
</p>
   <!-- l. 325 -->
<pre class='lstlisting' id='listing-2'><span class='label'><a id='x1-2080r1'></a><span class='ecrm-0600'>1</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>ifndef</span></span><span style='color:#000000'> <span class='ectt-1000'>LOGBARRIER</span> 
</span><span class='label'><a id='x1-2081r2'></a><span class='ecrm-0600'>2</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>define</span></span><span style='color:#000000'> <span class='ectt-1000'>LOGBARRIER</span> 
</span><span class='label'><a id='x1-2082r3'></a><span class='ecrm-0600'>3</span></span> 
<span class='label'><a id='x1-2083r4'></a><span class='ecrm-0600'>4</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>include</span></span><span style='color:#000000'> </span><span style='color:#FF0000'><span class='ectt-1000'>"</span></span><span style='color:#FF0000'><span class='ectt-1000'>newton</span></span><span style='color:#FF0000'><span class='ectt-1000'>.</span></span><span style='color:#FF0000'><span class='ectt-1000'>h</span></span><span style='color:#FF0000'><span class='ectt-1000'>"</span></span> 
<span class='label'><a id='x1-2084r5'></a><span class='ecrm-0600'>5</span></span> 
<span class='label'><a id='x1-2085r6'></a><span class='ecrm-0600'>6</span></span><span style='color:#0000FF'><span class='ectt-1000'>struct</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier : ObjectiveBase&lt;LogBarrier&gt; {</span> 
</span><span class='label'><a id='x1-2086r7'></a><span class='ecrm-0600'>7</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>value_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2087r8'></a><span class='ecrm-0600'>8</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>gradient_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2088r9'></a><span class='ecrm-0600'>9</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>MatrixXd</span></span><span style='color:#000000'> <span class='ectt-1000'>hessian_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2089r10'></a><span class='ecrm-0600'>10</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>newtonDirection_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2090r11'></a><span class='ecrm-0600'>11</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>bool</span></span><span style='color:#000000'> <span class='ectt-1000'>converged_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2091r12'></a><span class='ecrm-0600'>12</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>stepsize_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'><span class='ectt-1000'>;</span></span> 
<span class='label'><a id='x1-2092r13'></a><span class='ecrm-0600'>13</span></span> 
<span class='label'><a id='x1-2093r14'></a><span class='ecrm-0600'>14</span></span><span class='ectt-1000'>    </span><span style='color:#009900'><span class='ectt-1000'>//</span></span><span style='color:#009900'> <span class='ectt-1000'>Assume of the program min c^T x s.t. Ax &lt;= b.</span> 
</span><span class='label'><a id='x1-2094r15'></a><span class='ecrm-0600'>15</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>LogBarrier</span></span><span style='color:#000000'><span class='ectt-1000'>(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>MatrixXd&amp; A,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; b,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; c,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>t = 1) : A_(A), b_(b), c_(c), t_(t), m_(A.rows()), n_(A.cols()) {}</span> 
</span><span class='label'><a id='x1-2095r16'></a><span class='ecrm-0600'>16</span></span> 
<span class='label'><a id='x1-2096r17'></a><span class='ecrm-0600'>17</span></span><span style='color:#0000FF'><span class='ectt-1000'>private</span></span><span style='color:#000000'><span class='ectt-1000'>:</span></span> 
<span class='label'><a id='x1-2097r18'></a><span class='ecrm-0600'>18</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>MatrixXd</span></span><span style='color:#000000'> <span class='ectt-1000'>A_;</span> 
</span><span class='label'><a id='x1-2098r19'></a><span class='ecrm-0600'>19</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>b_;</span> 
</span><span class='label'><a id='x1-2099r20'></a><span class='ecrm-0600'>20</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>c_;</span> 
</span><span class='label'><a id='x1-2100r21'></a><span class='ecrm-0600'>21</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>t_;</span> 
</span><span class='label'><a id='x1-2101r22'></a><span class='ecrm-0600'>22</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>m_, n_;</span> 
</span><span class='label'><a id='x1-2102r23'></a><span class='ecrm-0600'>23</span></span><span style='color:#000000'><span class='ectt-1000'>};</span></span> 
<span class='label'><a id='x1-2103r24'></a><span class='ecrm-0600'>24</span></span> 
<span class='label'><a id='x1-2104r25'></a><span class='ecrm-0600'>25</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>endif</span></span><span style='color:#000000'> </span><span style='color:#009900'><span class='ectt-1000'>//</span></span><span style='color:#009900'> <span class='ectt-1000'>LOGBARRIER</span></span></pre>
   <!-- l. 353 -->
<pre class='lstlisting' id='listing-3'><span class='label'><a id='x1-2105r1'></a><span class='ecrm-0600'>1</span></span><span style='color:#0000FF'><span class='ectt-1000'>#</span></span><span style='color:#0000FF'><span class='ectt-1000'>include</span></span><span style='color:#000000'> </span><span style='color:#FF0000'><span class='ectt-1000'>"</span></span><span style='color:#FF0000'><span class='ectt-1000'>logbarrier</span></span><span style='color:#FF0000'><span class='ectt-1000'>.</span></span><span style='color:#FF0000'><span class='ectt-1000'>h</span></span><span style='color:#FF0000'><span class='ectt-1000'>"</span></span> 
<span class='label'><a id='x1-2106r2'></a><span class='ecrm-0600'>2</span></span> 
<span class='label'><a id='x1-2107r3'></a><span class='ecrm-0600'>3</span></span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::value_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2108r4'></a><span class='ecrm-0600'>4</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>t_ * c_.dot(x) - (b_ - A_ * x).array().log().sum();</span> 
</span><span class='label'><a id='x1-2109r5'></a><span class='ecrm-0600'>5</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2110r6'></a><span class='ecrm-0600'>6</span></span> 
<span class='label'><a id='x1-2111r7'></a><span class='ecrm-0600'>7</span></span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::gradient_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2112r8'></a><span class='ecrm-0600'>8</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>s = b_ - A_ * x;</span> 
</span><span class='label'><a id='x1-2113r9'></a><span class='ecrm-0600'>9</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>t_ * c_ + A_.transpose() * s.cwiseInverse();</span> 
</span><span class='label'><a id='x1-2114r10'></a><span class='ecrm-0600'>10</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2115r11'></a><span class='ecrm-0600'>11</span></span> 
<span class='label'><a id='x1-2116r12'></a><span class='ecrm-0600'>12</span></span><span style='color:#000000'><span class='ectt-1000'>MatrixXd</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::hessian_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2117r13'></a><span class='ecrm-0600'>13</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>s = b_ - A_ * x;</span> 
</span><span class='label'><a id='x1-2118r14'></a><span class='ecrm-0600'>14</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>s_inv_sq = s.array().square().inverse();</span> 
</span><span class='label'><a id='x1-2119r15'></a><span class='ecrm-0600'>15</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>A_.transpose() * s_inv_sq.asDiagonal() * A_;</span> 
</span><span class='label'><a id='x1-2120r16'></a><span class='ecrm-0600'>16</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2121r17'></a><span class='ecrm-0600'>17</span></span> 
<span class='label'><a id='x1-2122r18'></a><span class='ecrm-0600'>18</span></span><span style='color:#000000'><span class='ectt-1000'>VectorXd</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::newtonDirection_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2123r19'></a><span class='ecrm-0600'>19</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>-(hessian_impl(x).lu().solve(gradient_impl(x)));</span> 
</span><span class='label'><a id='x1-2124r20'></a><span class='ecrm-0600'>20</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2125r21'></a><span class='ecrm-0600'>21</span></span> 
<span class='label'><a id='x1-2126r22'></a><span class='ecrm-0600'>22</span></span><span style='color:#0000FF'><span class='ectt-1000'>bool</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::converged_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2127r23'></a><span class='ecrm-0600'>23</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>it &gt;= 27;</span> 
</span><span class='label'><a id='x1-2128r24'></a><span class='ecrm-0600'>24</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2129r25'></a><span class='ecrm-0600'>25</span></span> 
<span class='label'><a id='x1-2130r26'></a><span class='ecrm-0600'>26</span></span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>LogBarrier::stepsize_impl(</span></span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>VectorXd&amp; x,</span> </span><span style='color:#0000FF'><span class='ectt-1000'>int</span></span><span style='color:#000000'> <span class='ectt-1000'>it)</span> </span><span style='color:#0000FF'><span class='ectt-1000'>const</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2131r27'></a><span class='ecrm-0600'>27</span></span><span class='ectt-1000'>    </span><span style='color:#009900'><span class='ectt-1000'>//</span></span><span style='color:#009900'> <span class='ectt-1000'>TODO: Should optimize this to resuse previously computed values if possible.</span> 
</span><span class='label'><a id='x1-2132r28'></a><span class='ecrm-0600'>28</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>lambda = sqrt(gradient_impl(x).dot(hessian_impl(x).lu().solve(gradient_impl(x))));</span> 
</span><span class='label'><a id='x1-2133r29'></a><span class='ecrm-0600'>29</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>alpha;</span> 
</span><span class='label'><a id='x1-2134r30'></a><span class='ecrm-0600'>30</span></span> 
<span class='label'><a id='x1-2135r31'></a><span class='ecrm-0600'>31</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>double</span></span><span style='color:#000000'> <span class='ectt-1000'>m_lambda = m_*lambda;</span> 
</span><span class='label'><a id='x1-2136r32'></a><span class='ecrm-0600'>32</span></span> 
<span class='label'><a id='x1-2137r33'></a><span class='ecrm-0600'>33</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>if</span></span><span style='color:#000000'> <span class='ectt-1000'>(m_lambda &lt;= 0.5) {</span> 
</span><span class='label'><a id='x1-2138r34'></a><span class='ecrm-0600'>34</span></span><span class='ectt-1000'>        </span><span style='color:#000000'><span class='ectt-1000'>alpha</span></span><span style='color:#000000'> <span class='ectt-1000'>= (1+m_lambda)/(1+m_lambda+m_lambda*m_lambda);</span> 
</span><span class='label'><a id='x1-2139r35'></a><span class='ecrm-0600'>35</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span><span style='color:#000000'> </span><span style='color:#0000FF'><span class='ectt-1000'>else</span></span><span style='color:#000000'> <span class='ectt-1000'>{</span> 
</span><span class='label'><a id='x1-2140r36'></a><span class='ecrm-0600'>36</span></span><span class='ectt-1000'>        </span><span style='color:#000000'><span class='ectt-1000'>alpha</span></span><span style='color:#000000'> <span class='ectt-1000'>= 1/(1+m_lambda);</span> 
</span><span class='label'><a id='x1-2141r37'></a><span class='ecrm-0600'>37</span></span><span class='ectt-1000'>    </span><span style='color:#000000'><span class='ectt-1000'>}</span></span> 
<span class='label'><a id='x1-2142r38'></a><span class='ecrm-0600'>38</span></span> 
<span class='label'><a id='x1-2143r39'></a><span class='ecrm-0600'>39</span></span><span class='ectt-1000'>    </span><span style='color:#0000FF'><span class='ectt-1000'>return</span></span><span style='color:#000000'> <span class='ectt-1000'>alpha;</span> 
</span><span class='label'><a id='x1-2144r40'></a><span class='ecrm-0600'>40</span></span><span style='color:#000000'><span class='ectt-1000'>}</span></span></pre>
<!-- l. 396 --><p class='indent'>   Further detailed code can be found on my github page.
                                                                                         
                                                                                         
</p><!-- l. 1 --><p class='noindent'>
</p>
   <h3 class='likesectionHead' id='references'><a id='x1-3000'></a>References</h3>
<!-- l. 1 --><p class='noindent'>
   </p><div class='thebibliography'>
   <p class='bibitem'><span class='biblabel'>
 [1]<span class='bibsp'>   </span></span><a id='Xnesterov2018lectures'></a>Yurii Nesterov. <span class='ecti-1095'>Lectures on Convex Optimization</span>, volume 137 of <span class='ecti-1095'>Springer Optimization and
   Its Applications</span>. Springer, 2 edition, 2018.
</p>
   </div>
    
</body> 
</html>